/*****************************************************************************
* Arduino/Roomba Create Pathwalker
*
* This is a demonstration of the Roomba Path Walker.
* The project is intended to demonstrate robot programming.
* Robots are not "smart", they simply follow instructions.
*
* This Arduino program will drive a Roomba Create through a "maze".
* The "maze" actually only has one pathway ending in a dead-end
* Using a simple alogrithm, the Create will navigate to the dead-end
*
* Algorithm at: https://www.dropbox.com/s/xilimed15mzz19k/PathWalker%20Flowchart.png?dl=1
* Video at:     https://www.youtube.com/watch?v=5OqIQKldaHk
*
*
* SCROLL TO THE BOTTOM OF THIS FILE TO SEE THE IMPLEMENTAITON OF THE MAIN PATHWALKER ALGORITHM
* Everything above that is functions to implement driving, etc.
*
* The intent is that students would be interested in the alogrighm implemenation and how it matches
* the flowchart at https://www.dropbox.com/s/xilimed15mzz19k/PathWalker%20Flowchart.png?dl=1
* One idea is to move everything in this file (including init() and loop() into a sepearte header that 
* only the advanced student would ever look at.  That header would call pathwalker() from the init() function
* and this file would only contain the pathwalker algorithm.
*
***************************************************************************** */

/*******************************************
* DEFINE CONNECTIONS FROM ROOMBA TO ARDUINO
******************************************/

// Brown wire Create Pin:3:RXD  TO Arduino Pin:13:TXD  
// Black wire Create Pin:4:TXD  TO Arduino Pin:12:RXD     
// Green wire Create Pin:5:BRC  TO Arduino Pin:11:BRC

int rxPin = 12;
int txPin = 13;
int ddPin = 11;

#include <SoftwareSerial.h>
SoftwareSerial mySerial(rxPin, txPin);


/*****************************************************************************
* To perform a 90 degree left or right turn, the wheel count is used.
# I have found each Roomba needs fine tuning.  Adjust these counts as necessary
******************************************************************************/
#define COUNTS_PER_LEFT_TURN   431
#define COUNTS_PER_RIGHT_TURN  410


/**********************************************************
*  Songs to play when we start, finish, or hit a wall
************************************************************/

unsigned char song_start[] = {
    60, 8,
    65, 8,
    69, 8,
    72, 16,
    69, 8,
    72, 32
};

unsigned char song_finish[] = {
    88, 8,
    88, 16,
    88, 16,
    84, 8,
    88, 16,
    91, 32,
    79, 16
};

unsigned char song_bumper[] = {
    81, 12,
    81, 12,
    71, 24
};

void playSong(unsigned char *song, unsigned char len)
{
    mySerial.write(140);
    mySerial.write(1);
    mySerial.write(len/2);

    for (int i = 0; i < len; ++i)
    {
     mySerial.write(song[i]);
 }

    mySerial.write(141);
    mySerial.write(1);
}

/**************************************
* Light the power LED
***************************************/
#define POWER_LED_RED    255
#define POWER_LED_GREEN  0
#define POWER_LED_ORANGE 128

#define POWER_LED_ON     255
#define POWER_LED_OFF    0 

void lightPower(unsigned char color, unsigned char intensity)
{
    int zero = 0;
    
    mySerial.write(139);
    mySerial.write(zero);
    mySerial.write(color);
    mySerial.write(intensity);
}

/***************************************
*  readSerialByte()
*  
*  Read one byte from the serial port
*  and return as an unsigned char
*************************************** */
unsigned char readSerialByte () {
    
    unsigned char serialByte;
    while (mySerial.available() <= 0) {
        delay(1);
    }
    serialByte = mySerial.read();
    return serialByte;
}

/***************************************
*  readSerialWord()
*  
*  Read two bytes from the serial port
*  and return as an unsigned short
************************************** */
unsigned short readSerialWord () {
    
    unsigned short serialWord;

    serialWord =  readSerialByte();
    serialWord =  serialWord << 8;
    serialWord += readSerialByte();
    return serialWord;
}


/***************************************
*  getBumpers()
*  
*  Reads the state of the bumper
************************************** */
#define BUMPER_LEFT    2
#define BUMPER_RIGHT   1
#define BUMPER_FRONT   3
unsigned char getBumpers()
{
    unsigned char bumpers;
    mySerial.write(142);
    mySerial.write(7);
    bumpers = readSerialByte();
    //  Mask out the wheel drop bits so caller can do a simple compare
    bumpers = bumpers & BUMPER_FRONT;
    return bumpers;
}


/***************************************
*  getButtons()
*  
*  Reads the state of all buttons
*  Returns bitmask indicating which buttons are on
*************************************** */
#define BUTTON_CLOCK    7
#define BUTTON_SCHEDULE 6
#define BUTTON_DAY      5
#define BUTTON_HOUR     4
#define BUTTON_MINUTE   3
#define BUTTON_DOCK     2
#define BUTTON_SPOT     1
#define BUTTON_CLEAN    0

unsigned char getButtons()
{
    unsigned char buttons;
    mySerial.write(142);
    mySerial.write(18);
    buttons = readSerialByte();
    return buttons;
}

/***************************************
*  startWheels(leftWeelSpeed, rightWheelSpeed)
*
*   Start the wheels turning, each at the specified speed
*   To go straight, make both values the same.
*   1  to  500 is forwards
*   -1 to -500 is backwards
*   0 is stop
************************************** */
void startWheels(int rsp = 0, int lsp = 0) {
    mySerial.write(145);
    mySerial.write(highByte(rsp));
    mySerial.write(lowByte(rsp));
    mySerial.write(highByte(lsp));
    mySerial.write(lowByte(lsp));
}

/***************************************
*   stopWheels()
*
*   Stop both wheels from turning
*   Equivalient to startWheels(0, 0)
*************************************** */
void stopWheels() {
    startWheels(0, 0);
    delay(30);
}

/***************************************
* Get the Left and Right wheel counts
****************************************/
unsigned short getLeftWheelCount()
{
    unsigned short count;
    mySerial.write(142);
    mySerial.write(43);
    count = readSerialWord();
    return count;
}

unsigned short getRightWheelCount()
{
    unsigned short count;
    mySerial.write(142);
    mySerial.write(44);
    count = readSerialWord();
    return count;
}

/****************************************************
 * Turn
 * Turn 90 degrees left or right using the wheel count 
 ******************************************************/
#define LEFT  1
#define RIGHT 2

void turn(int direction)
{
    int counts_per_turn;
    
    unsigned long currentCount, initialCount, targetCount;
    
    if (direction == LEFT) {
        initialCount = getRightWheelCount();
        startWheels(25, -25);
        counts_per_turn = COUNTS_PER_LEFT_TURN;
        Serial.println("TURNING LEFT");
    } else {
        initialCount = getLeftWheelCount();
        startWheels(-25, 25);  
        counts_per_turn = COUNTS_PER_RIGHT_TURN;
        Serial.println("TURNING RIGHT");
    }
    targetCount  = initialCount + (counts_per_turn);
    delay(1000);
    while (true)
    {
        delay(30);
        
        if (direction == LEFT) currentCount = getRightWheelCount(); else currentCount = getLeftWheelCount();
        if (currentCount  < initialCount)  currentCount  += (unsigned short) 0xffff;
        
        if (currentCount >= targetCount) {
            // Stop if we've reached the target
            Serial.println("TURNING TARGET REACHED");
            stopWheels();
            break;
        }
    }
}

/****************************************************
 * Reverse
 * Backup a little but
 ******************************************************/
void reverse()
{
    #define MAX_REVERSE_COUNT (1900 / 30)

    unsigned long currentCount, currentLeftCount, currentRightCount;
    unsigned long initialCount, initialLeftCount, initialRightCount;
    unsigned long deltaLeftCount, deltaRightCount;
    int leftSpeed, rightSpeed;

    initialLeftCount  = getLeftWheelCount();
    initialRightCount = getRightWheelCount();
    initialCount = initialLeftCount;

    leftSpeed = rightSpeed = -25;
    startWheels(leftSpeed, rightSpeed);
    delay(500);

    int count = 0;
    while (true)
    {
        count += 1;
        if (count > MAX_REVERSE_COUNT)
        {
            stopWheels();
            break;
        }
        
        delay(30);
        
        currentLeftCount  = getLeftWheelCount();
        currentRightCount = getRightWheelCount();

        if (currentLeftCount  < initialLeftCount)  currentLeftCount  += (unsigned short) 0xffff;
        if (currentRightCount < initialRightCount) currentRightCount += (unsigned short) 0xffff;
        
        currentCount = currentLeftCount;
        
        // Check that we are going straight
        deltaLeftCount  = currentLeftCount  - initialLeftCount;
        deltaRightCount = currentRightCount - initialRightCount;
        

        if (deltaLeftCount < (deltaRightCount - 3)) { 
            leftSpeed  = leftSpeed - 3;
            rightSpeed = rightSpeed + 3;
            startWheels(leftSpeed, rightSpeed);
            initialLeftCount  = currentLeftCount;
            initialRightCount = currentRightCount;
        } else if (deltaRightCount < (deltaLeftCount - 3)) { 
            rightSpeed = rightSpeed - 3;
            leftSpeed  = leftSpeed  + 3;
            startWheels(leftSpeed, rightSpeed);
            initialLeftCount  = currentLeftCount;
            initialRightCount = currentRightCount;
        }

    }
}

/*****************************************************************************
* drive()
# This function drives the roomba forward until it hits a wall
******************************************************************************/
#define NORMAL_SPEED    125  

unsigned long drive()
{
    unsigned long currentCount, currentLeftCount, currentRightCount;
    unsigned long initialCount, initialLeftCount, initialRightCount;
    unsigned long deltaLeftCount, deltaRightCount;
    int leftSpeed, rightSpeed, bumper;

    initialLeftCount  = getLeftWheelCount();
    initialRightCount = getRightWheelCount();
    initialCount = initialLeftCount;
    
    currentCount = initialCount;

    // Start driving
    leftSpeed = rightSpeed = NORMAL_SPEED;
    startWheels(leftSpeed, rightSpeed);
    Serial.println("DRIVING FORWARD");

    // I have found that you MUST wait a bit after starting before getting the wheel count.
    // If you get the count too soon after you first start driving, you get a bogus (usually overly large) number.
    delay(1000);
    
    while (true)
    {
        // Let the Roomba drive a bit
        delay(30);

        // See if we hit a wall
        bumper = getBumpers();
        
        if (bumper != 0) {
            stopWheels();
            playSong(song_bumper, sizeof(song_bumper));
            Serial.println("I RAN INTO A WALL");
            return (currentCount - initialCount);
        }
        
        currentLeftCount  = getLeftWheelCount();
        currentRightCount = getRightWheelCount();

        if (currentLeftCount  < initialLeftCount)  currentLeftCount  += (unsigned short) 0xffff;
        if (currentRightCount < initialRightCount) currentRightCount += (unsigned short) 0xffff;
        
        currentCount = currentLeftCount;
        
        // Check that we are going straight
        deltaLeftCount  = currentLeftCount  - initialLeftCount;
        deltaRightCount = currentRightCount - initialRightCount;
        
        if (deltaLeftCount > (deltaRightCount + 3)) { 
            leftSpeed  = leftSpeed + 3;
            rightSpeed = rightSpeed - 3;
            startWheels(leftSpeed, rightSpeed);
            initialLeftCount  = currentLeftCount;
            initialRightCount = currentRightCount;
        } else if (deltaRightCount > (deltaLeftCount + 3)) { 
            rightSpeed = rightSpeed + 3;
            leftSpeed  = leftSpeed  - 3;
            startWheels(leftSpeed, rightSpeed);
            initialLeftCount  = currentLeftCount;
            initialRightCount = currentRightCount;
        }
    }
}

/***************************************
*   Main Arduino setup function
****************************************/

#define ONE_FOOT 600

void setup() {

    int i;
    unsigned long distance;
    unsigned char buttonBits, mask;


    // Initialize console serial port
    Serial.begin(9600);
    
    // Set up our own serial for talking to the CREATE
    pinMode(txPin, OUTPUT);
    pinMode(rxPin, INPUT);
    mySerial.begin(19200);
    
    
    // Pin 13 can be used for controlling the onboard LED
    pinMode(13,OUTPUT);
    
    // Attempt to set the BAUD Rate.  This does not appear to work
    // So instead, after replacing the Roomba battery, do the following:
    // Press the START button so the light is on
    // Hold the START button till light turns off and a tune plays (about 30 seconds)
    pinMode(ddPin,OUTPUT);
    digitalWrite(ddPin, LOW);
    delay(2000);
    digitalWrite(ddPin, HIGH);
    delay(100);
    digitalWrite(ddPin, LOW);
    delay(100);
    digitalWrite(ddPin, HIGH);
    delay(100);
    digitalWrite(ddPin, LOW);
    delay(100);
    digitalWrite(ddPin, HIGH);
    delay(100);
    digitalWrite(ddPin, LOW);
    delay(100);
    
    // Send the START command to the CREATE
    mySerial.write(128);
    delay(50);
    
    // Put CREATE into Safe mode
    mySerial.write(131);
    delay(50);

    // Make sure the CREATE is stopped
    stopWheels();

    // Wait till a button is pressed
    // The HOUR   button means GO
    // The DAY    button means calibrate left hand turn
    // The MINUTE button means calibrate right hand turn
    
    Serial.println("Waiting for HOUR button");
    while (true) {
        lightPower(POWER_LED_RED, POWER_LED_ON);
        delay(30);

        buttonBits = getButtons();
        if (buttonBits != 0)
        {
            mask = 1 << BUTTON_HOUR;
            if (buttonBits & mask) {
                // They pressed the HOUR button.  Break out of this wait loop and start it's travel
                break;
            }

            // Pressing the DAY button can be used to calibrate the Roomba
            // If after a full circle the Roomba is not facing the same direction,
            // Adjust COUNTS_PER_LEFT_TURN above
            mask = 1 << BUTTON_DAY;
            if (buttonBits & mask) 
            { 
                Serial.println("Calibrating LEFT hand turn.  Adjust COUNTS_PER_LEFT_TURN if I don't do a perfect 360");
                turn(LEFT); 
                delay(500);
                turn(LEFT); 
                delay(500);
                turn(LEFT); 
                delay(500);
                turn(LEFT); 
            } 

            // Pressing the MINUTE button can be used to calibrate the Roomba
            // If after a full circle the Roomba is not facing the same direction,
            // Adjust COUNTS_PER_RIGHT_TURN above
            mask = 1 << BUTTON_MINUTE;
            if (buttonBits & mask) 
            { 
                Serial.println("Calibrating RIGHT hand turn.  Adjust COUNTS_PER_RIGHT_TURN if I don't do a perfect 360");
                turn(RIGHT); 
                delay(500);
                turn(RIGHT); 
                delay(500);
                turn(RIGHT); 
                delay(500);
                turn(RIGHT); 
            }
            
        }
    }






    
    /***********************************************************************
    ************************************************************************
    * START OF THE MAIN PATHWALKER ALGORITHM
    *
    * Algorithm at: https://www.dropbox.com/s/xilimed15mzz19k/PathWalker%20Flowchart.png?dl=1
    *
    ************************************************************************
    ************************************************************************/

    // Make the power light orange and sing the starting song
    lightPower(POWER_LED_ORANGE, POWER_LED_ON); 
    delay(1000);
    playSong(song_start, sizeof(song_start));

    // Variable to keep track of whether we just turned right like the algorthim says
    int turnedRight = false;
    
    while(1)
    {
        // Drive forward till we hit a wall
        distance = drive();

        // Backup a little (and pause to give audience a chance to think about what's next)
        reverse();
        delay(2000);


        // Did we drive forward more than a foot?
        if (distance > ONE_FOOT)
        {
            // Yes, turn left and continue
            turn(LEFT);

            // Remember that we did not just turn right
            turnedRight = false;
            continue;
        }

        // No, we did not go less than a foot.  Did we just turn right?
        if ( !turnedRight) 
        {
            // No, we did not just turn right twice.
            // Turn right twice now and remember that fact
            turn(RIGHT);
            turn(RIGHT);
            turnedRight = true;
        }

        // Yes, we just turned right,  That means we've reached the end!

        // Turn left to face the flage and sing our finish song.
        turn(LEFT);
        playSong(song_finish, sizeof(song_finish));
        lightPower(POWER_LED_GREEN, POWER_LED_ON); 
        break;
    }
}

/**************************************
*   Main Arduino loop function
***************************************/
void loop() { }
